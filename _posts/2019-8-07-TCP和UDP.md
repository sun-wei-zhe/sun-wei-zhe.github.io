---
layout:     post
title:      浅谈 TCP & UDP
subtitle:   什么是三握四挥，TCP如何保证可靠性，粘包分包
date:       2019-08-07
author:     SWZ
header-img: img/post-bg-tcp_udp.jpg
catalog: true
tags:
    - 计算机网络
---

## 前言



---

## TCP（Transmission Control Protocol，传输控制协议）

TCP是一种**面向连接**、**可靠**的、**基于字节流**的传输层通信协议。每一条TCP连接只能有两个端点（endpoint），点对点（一对一）。TCP还提供了**全双工通信**服务，即可同时收和发，比如A和B打电话，A一直在讲话，如果B不回点什么的话A可能觉得线路断了，所以B会时不时“嗯”一下保持反馈。

### 三次握手

![](https://image-blog-1257507325.cos.ap-shanghai.myqcloud.com/TCP%E5%92%8CUDP/%E4%B8%89%E6%8F%A1.png)

1. 其中TCP客户端主动发起TCP连接建立，握手需要在TCP客户端与服务器之间交换三个TCP报文段。首先TCP客户端向TCP服务器发送TCP连接报文段，并进入**同步已发送状态（SYN-SENT）**。TCP连接请求报文段首部中的**同步位SYN**被设置为1，表明这是一个TCP连接请求报文段。**序号字段seq**被设置了一个初始值x，作为TCP客户端所选择的初始序号（注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号）。

2. TCP服务器收到TCP请求报文段后，如果同意建立连接则向客户端发送TCP连接请求确认报文段，并进入**同步已接收状态（SYN-RCVD）**。该报文段首部中的**同步位SYN**和**确认位ACK**都设置为1，表明这是一个TCP连接请求确认报文段。**序号字段seq**被设置了一个初始值y，作为TCP服务器所选择的初始序号，**确认号字段ack**被设置成了x+1，这是对TCP客户端所选择的初始序号的确认（注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样需要消耗掉一个序号）。

3. TCP客户端在收到TCP连接请求确认报文段后，还要向TCP服务器发送一个普通的TCP确认报文段，并进入**连接已建立状态（ESTABLISHED）**。该报文段首部中的**确认位ACK**被设置为1，表明这是一个普通的TCP确认报文段。**序号字段seq**被设置为x+1，这是因为TCP客户端发送的第一个TCP报文段的序号为x，并且不携带数据，因此第二个报文段的序号为x+1（注意：TCP规定，普通的TCP确认报文段可以携带数据，如果不携带数据，则不消耗序号）。**确认号字段ack**被设置为y+1，这是对TCP服务器所选择的初始序号的确认。

4. TCP服务器收到该确认报文段后进入**连接已建立状态（ESTABLISHED）**。

> **序号：**用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
>
> **确认号：**期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
>
> **数据偏移：**指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
>
> **控制位：**八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。
>
> **CWR：**CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；
>
> **ECE：**若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；
>
> **URG：**该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；
>
> **ACK：**该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；
>
> **PSH：**该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；
>
> **RST：**该位设为 1，表示 TCP 连接出现异常必须强制断开连接；
>
> **SYN：**用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；
>
> **FIN：**该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。
>
> 每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；
>
> **窗口：**窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

**问题：两次握手可以么，三次是否多余？**
三握不多余，这是为了防止已经失效的连接请求报文段突然又传到了TCP服务器，因而导致错误。

**问题：三次握手真正的原因是什么？**
为了确认双方都知道 “对方愿意建立连接并且对方知道自己愿意建立连接“的这个事实。

### 四次挥手

![](https://image-blog-1257507325.cos.ap-shanghai.myqcloud.com/TCP%E5%92%8CUDP/%E5%9B%9B%E6%8C%A5.png)

1. TCP客户端会发送TCP连接释放报文段并进入**终止等待1状态（FIN-WAIT-1）**，该报文段中的**终止位FIN**和**确认位ACK**的值都被设为1，表明这是一个TCP释放报文段，**序号seq字段**的值设置为u，它等于客户端已传送数据的最后一个字节的序号加1（注意TCP规定终止位FIN为1的报文段即使不携带数据也要消耗掉一个序号）。**确认号ack字段**的值设置为v，它等于客户端已收到数据的最后一个字节的序号加1。

2. TCP服务端在收到TCP连接释放报文段后会发送一个普通的TCP确认报文段并进入**关闭等待状态（CLOSE-WAIT）**。该报文段首部中的**确认位ACK**的值被设置为1，表明这是一个普通的TCP确认报文段，**序号seq字段**的值设置为v，它等于TCP服务器已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号所匹配。**确认号ack字段**的值设置为u+1，这是对TCP连接释放报文段的确认。此时，从TCP客户端到TCP服务端这个方向的连接就释放了，这时的TCP连接处于半关闭状态，但TCP服务端如果还有数据要发送TCP客户端仍要接收，也就是说从TCP服务端到TCP客户端这个方向的连接并未关闭。

3. TCP客户端收到TCP确认报文段后就进入**终止等待2状态（FIN-WAIT-2）**，等待TCP服务器发出的连接释放报文段。

4. 若TCP服务器已经没有数据要发送了，则向TCP客户端发送TCP连接释放报文段并进入**最后确认状态（LAST-ACK）**。该报文段首部中的**终止位FIN**和**确认位ACK**的值都设置为1，表明这是一个TCP连接释放报文段，**序号seq字段**为w，**确认号ack字段**的值为u+1，这是对	之前收到的TCP连接释放报文段的重复确认。

5. TCP客户端收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入**时间等待状态（TIME-WAIT）**，在经过2MSL（240s）才会进入**关闭状态（CLOSED）**，该报文段首部的**确认位ACK**的值被设为1，表明这是一个普通的TCP确认报文段，**序号seq字段**的值被设置为u+1，这是因为TCP客户端之前发送的TCP连接释放报文段虽然不携带数据，但也要消耗掉一个序号。确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。

6. TCP服务器收到该报文段后就进入**关闭状态（CLOSED）**。

> 处于TIME-WAIT状态的客户端必须等待2MSL时间后，才会进入CLOSED状态。MSL（Maximum Segment Lifetime）最长报文段寿命，RFC 793 建议设为两分钟，对于现在的网络，MSL= 2分钟可能太长了一些，我们可根据具体情况使用更小的MSL值。

**问题：为什么要经过2MSL后才进入关闭状态？**



### 粘包&拆包

#### 什么是粘包和拆包

第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。

第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。

#### 为什么会发生粘包和拆包

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

#### 解决方案

由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的。

- **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
- **将消息分为消息头和消息体：**消息头中包含表示消息总长度（或者消息体长度）的字段。
- 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。

### 如何保证传输可靠性

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

#### 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

#### 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

**实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段**，此数据段仅包含一个字节来获取最新的窗口大小信息。

#### 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四个算法来进行拥塞控制：

**慢开始、拥塞避免、快重传、快恢复。**

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

**慢开始与拥塞避免**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

---

## UDP（User Datagram Protocol，用户数据报协议）

UDP是一种**无连接**的、**不可靠**的、但**传输效率较高**的通信协议。UDP 不止支持一对一的传输方式，有单播，多播，广播的功能。

### 面向无连接

首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了。
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。

###  UDP是面向报文的

发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文

### UDP 头部

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

（1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。

（3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。

（5）UDP使用**尽最大努力交付，**即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

（6）UDP是**面向报文**的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

---

## 总结

|              | UDP                                                  | TCP                                            |
| :----------- | :--------------------------------------------------- | ---------------------------------------------- |
| 是否连接     | 无连接                                               | 面向连接                                       |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制，不保证数据顺序 | 可靠传输，使用流量控制和拥塞控制，保证数据顺序 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信           | 只能是一对一通信                               |
| 传输方式     | 面向报文                                             | 面向字节流                                     |
| 首部开销     | 首部开销小，仅8字节                                  | 首部最小20字节，最大60字节                     |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等）           | 适用于要求可靠传输的应用，例如文件传输         |

